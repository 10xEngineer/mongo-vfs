// Generated by CoffeeScript 1.3.3
(function() {
  var Connection, Db, GridStore, MongoFS, Path, Server, Stream, assert, async, mongodb, _;

  MongoFS = require('../lib/mongofs');

  mongodb = require('mongodb');

  Stream = require('stream');

  Path = require('path');

  async = require('async');

  assert = require('assert');

  _ = require('underscore');

  Db = mongodb.Db;

  Server = mongodb.Server;

  Connection = mongodb.Connection;

  GridStore = mongodb.GridStore;

  describe('mongo-vfs', function() {
    var chunks, credentials, db, files, mfs;
    var options;
    credentials = {
      database: 'mongofs_test',
      host: 'localhost',
      port: Connection.DEFAULT_PORT
    };
    mfs = new MongoFS(credentials);
    db = null;
    files = null;
    chunks = null;
    before(function(done) {
      //process.stdout.write('\u001B[2J\u001B[0;0f');
      return mfs.open(done);
    });
    beforeEach(function(done) {
      var addCoffeeFile, addDirectory, addFile, server;
      options = {
        bucketId: 'test'
      };

      server = new Server(credentials.host, credentials.port, {});
      db = new Db(credentials.database, server);
      db.open(function(err, db) {
        return async.series([
          function(next) {
            return db.collection('fs.files', function(err, _files) {
              files = _files;
              return files.remove(function(err) {
                return _.defer(next, err);
              });
            });
          }, function(next) {
            return db.collection('fs.chunks', function(err, _chunks) {
              chunks = _chunks;
              return chunks.remove(function(err) {
                return _.defer(next, err);
              });
            });
          }, addFile('/folder', 'bar'), addFile('/folder', 'bar2'), addDirectory('/folder/folder2'), addCoffeeFile
        ], done);
      });
      addFile = function(path, filename, content) {
        if (content == null) {
          content = 'foo';
        }
        return function(next) {
          var gs;
          gs = new GridStore(db, filename, 'w', {
            metadata: {
              path: path,
              bucket: 'test'
            }
          });
          return gs.open(function(err) {
            return gs.write(content, function(err) {
              return gs.close(next);
            });
          });
        };
      };
      addDirectory = function(path) {
        return function(next) {
          var gs;
          gs = new GridStore(db, '.empty', 'w', {
            metadata: {
              path: path,
              bucket: 'test'
            }
          });
          return gs.open(function(err) {
            return gs.close(next);
          });
        };
      };
      return addCoffeeFile = function(next) {
        var gs;
        gs = new GridStore(db, 'mock.coffee', 'w', {
          metadata: {
            path: '/',
            bucket: 'test'
          },
          content_type: 'application/coffee'
        });
        return gs.open(function(err) {
          return gs.writeFile(__dirname + '/mock/mock.coffee', function(err) {
            return gs.close(next);
          });
        });
      };
    });
    describe('readfile', function() {
      return it('should read a file', function(done) {
        return mfs.readfile('/folder/bar', options, function(err, meta) {
          var data;
          if (err) {
            return done(err);
          }
          data = [];
          meta.stream.on('data', function(chunk) {
            return data.push(chunk);
          });
          return meta.stream.on('end', function() {
            data.join().should.eql('foo');
            return done();
          });
        });
      });
    });
    describe('mkfile', function() {
      it('should create a new temp file and return stream to it', function(done) {
        var stream = options.stream = new Stream();
        mfs.mkfile('/bar', options, function(err, meta) {
          if (err) {
            return done(err);
          }
          return files.findOne({
            filename: 'bar',
            'metadata.path': '/',
            'metadata.bucket': options.bucketId
          }, function(err, doc) {
            if (err) {
              done(err);
            }
            doc.should.exist;
            return done();
          });
        });
        stream.emit('data', 'Hello');
        return stream.emit('end');
      });
      return it('should reject if there is another file with the same name', function(done) {
        var stream = options.stream = new Stream();
        mfs.mkfile('/folder/bar', options, function(err, meta) {
          var fn;
          fn = function() {
            if (err) {
              throw err;
            }
          };
          fn.should["throw"](/^File/);
          return done();
        });
        stream.emit('data', 'Hello');
        return stream.emit('end');
      });
    });
    describe('mkdir', function() {
      it('should create .empty file in new directory', function(done) {
        return mfs.mkdir('/folder2', options, function(err, meta) {
          if (err) {
            return done(err);
          }
          return files.findOne({
            'metadata.path': '/folder2'
          }, function(err, doc) {
            if (err) {
              done(err);
            }
            doc.should.exist;
            return done();
          });
        });
      });
      return it('should reject if there already is directory with the same name', function(done) {
        return mfs.mkdir('/folder/folder2', options, function(err, meta) {
          var fn;
          fn = function() {
            if (err) {
              throw err;
            }
          };
          fn.should["throw"](/^Directory/);
          return done();
        });
      });
    });
    describe('rename', function() {
      it('should rename a file', function(done) {
        options.from = '/folder/bar';
        return mfs.rename('/baz', options, function(err) {
          var cursor;
          if (err) {
            return done(err);
          }
          cursor = files.find({
            filename: 'baz',
            'metadata.path': '/',
            'metadata.bucket': options.bucketId
          });
          return cursor.toArray(function(err, docs) {
            if (err) {
              return done(err);
            }
            docs.should.not.be.empty;
            cursor = files.find({
              filename: 'bar',
              'metadata.path': '/folder',
              'metadata.bucket': options.bucketId
            });
            return cursor.toArray(function(err, docs) {
              if (err) {
                return done(err);
              }
              docs.should.be.empty;
              return done();
            });
          });
        });
      });
      return it('should rename a directory', function(done) {
        options.from = '/folder/';
        return mfs.rename('/baz/', options, function(err) {
          var cursor;
          if (err) {
            return done(err);
          }
          cursor = files.find({
            'metadata.path': '/baz'
          });
          return cursor.toArray(function(err, docs) {
            if (err) {
              return done(err);
            }
            docs.should.not.be.empty;
            return files.find({
              'metadata.path': '/folder'
            }).toArray(function(err, docs) {
              if (err) {
                done(err);
              }
              docs.should.be.empty;
              return done();
            });
          });
        });
      });
    });
    describe('readdir', function() {
      return it('should list all files and folders in directory', function(done) {
        return mfs.readdir('/folder/', options, function(err, meta) {
          var data, stream;
          if (err) {
            return done(err);
          }
          meta.should.have.property('stream');
          stream = meta.stream;
          data = [];
          stream.on('data', function(chunk) {
            return data.push(chunk);
          });
          return stream.on('end', function() {
            data[0].should.be.a('object');
            data[0].should.have.property('name');
            data[0].should.have.property('mime');
            data[0].should.have.property('path');
            data[0].should.have.property('size');
            data.should.have.length(3);
            return done();
          });
        });
      });
    });
    describe('stat', function() {
      it('should return stat of a file', function(done) {
        return mfs.stat('/folder/bar', options, function(err, meta) {
          if (err) {
            return done(err);
          }
          meta.should.be.a('object');
          meta.should.have.property('name', 'bar');
          meta.should.have.property('mime');
          meta.should.have.property('path', '/folder');
          meta.should.have.property('size');
          return done();
        });
      });
      it('should return stat of a directory', function(done) {
        return mfs.stat('/folder/', options, function(err, meta) {
          if (err) {
            return done(err);
          }
          meta.should.be.a('object');
          meta.should.have.property('name', 'folder');
          meta.should.have.property('mime', 'inode/directory');
          meta.should.have.property('path', '/');
          meta.should.have.property('size', 3);
          return done();
        });
      });
      return it('should return error if the file or directory doesnt exist', function(done) {
        return mfs.stat('/foobar', options, function(err, meta) {
          var fn;
          fn = function() {
            if (err) {
              throw err;
            }
          };
          fn.should["throw"]();
          return done();
        });
      });
    });
    describe('copy', function() {
      return it('should create copy of existing file', function(done) {
        options.from = '/mock.coffee';
        return mfs.copy('/folder/bar_copy', options, function(err, meta) {
          if (err) {
            return done(err);
          }
          return files.findOne({
            filename: 'bar_copy',
            'metadata.path': '/folder',
            'metadata.bucket': options.bucketId
          }, function(err, doc) {
            if (err) {
              return done(err);
            }
            doc.should.exist;
            doc.should.be.a('object');
            doc.should.have.property('filename', 'bar_copy');
            doc.should.have.property('metadata');
            doc.metadata.should.have.property('path', '/folder');
            doc.should.have.property('contentType', 'application/coffee');
            return done();
          });
        });
      });
    });
    describe('rmfile', function() {
      return it('should remove file', function(done) {
        return files.findOne({
          filename: 'bar',
          'metadata.path': '/folder',
          'metadata.bucket': options.bucketId
        }, function(err, doc) {
          if (err) {
            return done(err);
          }
          return mfs.rmfile('/folder/bar', options, function(err) {
            if (err) {
              return done(err);
            }
            return chunks.find({
              files_id: doc._id
            }).toArray(function(err, docs) {
              if (err) {
                return done(err);
              }
              docs.should.be.empty;
              return files.findOne({
                filename: 'bar',
                'metadata.path': '/folder',
                'metadata.bucket': options.bucketId
              }, function(err, doc) {
                if (err) {
                  return done(err);
                }
                assert.equal(doc, null);
                return done();
              });
            });
          });
        });
      });
    });
    return describe('rmdir', function() {
      it('should remove empty directory', function(done) {
        return mfs.rmdir('/folder/folder2/', options, function(err, meta) {
          if (err) {
            return done(err);
          }
          return files.findOne({
            'metadata.path': '/folder/folder2'
          }, function(err, doc) {
            if (err) {
              return done(err);
            }
            assert.equal(doc, null);
            return done();
          });
        });
      });
      it('should not remove directory with files', function(done) {
        return mfs.rmdir('/folder', options, function(err, meta) {
          var fn;
          fn = function() {
            if (err) {
              throw err;
            }
          };
          fn.should["throw"](/not empty$/);
          return files.find({
            'metadata.path': /^\/folder/
          }).toArray(function(err, docs) {
            if (err) {
              return done(err);
            }
            docs.should.not.be.empty;
            return done();
          });
        });
      });
      return it('should remove directory with files when recursive flag is true', function(done) {
        options.recursive = true;
        return mfs.rmdir('/folder', options, function(err, meta) {
          if (err) {
            done(err);
          }
          return files.findOne({
            'metadata.path': /^\/folder/
          }, function(err, doc) {
            if (err) {
              return done(err);
            }
            assert.equal(doc, null);
            return done();
          });
        });
      });
    });
  });

}).call(this);
